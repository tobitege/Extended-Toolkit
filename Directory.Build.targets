<Project>
	<!-- 
		This file is automatically imported by all projects in the solution.
		It configures NuGet package generation to include referenced binaries.
	-->
	
	<PropertyGroup>
		<!-- Include all referenced assemblies in NuGet packages -->
		<CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
		
		<!-- Include build output in packages (can be overridden by individual projects) -->
		<IncludeBuildOutput Condition="'$(IncludeBuildOutput)' == ''">true</IncludeBuildOutput>
		
		<!-- Include referenced project outputs in packages -->
		<IncludeReferencedProjects>true</IncludeReferencedProjects>
		
		<!-- Generate symbols packages in the modern format -->
		<IncludeSymbols>true</IncludeSymbols>
		<SymbolPackageFormat>snupkg</SymbolPackageFormat>
		
		<!-- Embed all dependencies in the package lib folder -->
		<TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificBuildOutput);CopyProjectReferencesToPackage</TargetsForTfmSpecificBuildOutput>
		
		<!-- Suppress common NuGet warnings for all projects -->
		<NoWarn Condition="'$(NoWarn)' == ''">$(NoWarn);NU1012;NU5128</NoWarn>
		<TreatWarningsAsErrors>false</TreatWarningsAsErrors>
		<WarningsAsErrors />
		<WarningsNotAsErrors>NU1012;NU5128</WarningsNotAsErrors>
	</PropertyGroup>

	<!-- 
		Smart dependency inclusion for all Extended Toolkit projects.
		This target ensures that only necessary dependencies are included in NuGet packages,
		excluding framework assemblies while including all Extended Toolkit and third-party dependencies.
	-->
	<Target Name="CopyProjectReferencesToPackage" DependsOnTargets="ResolveReferences">
		<ItemGroup>
			<!-- Include all referenced assemblies -->
			<_AllReferences Include="@(ReferenceCopyLocalPaths)" />
			<_NuGetReferences Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' != ''" />
			<_ProjectReferenceOutputs Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.ReferenceSourceTarget)' == 'ProjectReference'" />
			
			<!-- Filter out framework assemblies (System.*, Microsoft.*, WindowsBase, etc.) -->
			<_FrameworkAssemblies Include="@(_AllReferences)" 
				Condition="$([System.String]::new('%(Filename)').StartsWith('System.')) OR 
						   $([System.String]::new('%(Filename)').StartsWith('Microsoft.VisualBasic')) OR 
						   $([System.String]::new('%(Filename)').StartsWith('Microsoft.Win32.')) OR 
						   $([System.String]::new('%(Filename)').StartsWith('Microsoft.CSharp')) OR 
						   '%(Filename)' == 'mscorlib' OR 
						   '%(Filename)' == 'netstandard' OR 
						   '%(Filename)' == 'WindowsBase' OR 
						   '%(Filename)' == 'PresentationCore' OR 
						   '%(Filename)' == 'PresentationFramework' OR 
						   $([System.String]::new('%(Filename)').StartsWith('PresentationFramework.')) OR 
						   '%(Filename)' == 'PresentationUI' OR 
						   '%(Filename)' == 'ReachFramework' OR 
						   '%(Filename)' == 'UIAutomationClient' OR 
						   '%(Filename)' == 'UIAutomationClientSideProviders' OR 
						   '%(Filename)' == 'UIAutomationProvider' OR 
						   '%(Filename)' == 'UIAutomationTypes' OR 
						   '%(Filename)' == 'Accessibility'" />
			
			<!-- Include only non-framework assemblies -->
			<_NonFrameworkAssemblies Include="@(_AllReferences)" Exclude="@(_FrameworkAssemblies);@(_NuGetReferences);@(_ProjectReferenceOutputs)" />
			<_AssemblyReferences Include="@(_NonFrameworkAssemblies)" Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.exe'" />
			
			<!-- Include filtered dependencies in package -->
			<BuildOutputInPackage Include="@(_AssemblyReferences)" />
		</ItemGroup>
		
		<Message Text="Including dependency: %(_NonFrameworkAssemblies.Identity)" Importance="low" />
	</Target>

	<!-- 
		Include all runtime dependencies in the package.
		This ensures that consumers get all necessary DLLs (excluding framework assemblies).
	-->
	<PropertyGroup>
		<TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);IncludeReferencedProjectInPackage</TargetsForTfmSpecificContentInPackage>
	</PropertyGroup>

	<Target Name="IncludeReferencedProjectInPackage" DependsOnTargets="ResolveReferences">
		<ItemGroup>
			<!-- Include all referenced assemblies -->
			<_AllReferences Include="@(ReferenceCopyLocalPaths)" />
			<_NuGetReferences Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' != ''" />
			<_ProjectReferenceOutputs Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.ReferenceSourceTarget)' == 'ProjectReference'" />
			
			<!-- Filter out framework assemblies -->
			<_FrameworkAssemblies Include="@(_AllReferences)" 
				Condition="$([System.String]::new('%(Filename)').StartsWith('System.')) OR 
						   $([System.String]::new('%(Filename)').StartsWith('Microsoft.VisualBasic')) OR 
						   $([System.String]::new('%(Filename)').StartsWith('Microsoft.Win32.')) OR 
						   $([System.String]::new('%(Filename)').StartsWith('Microsoft.CSharp')) OR 
						   '%(Filename)' == 'mscorlib' OR 
						   '%(Filename)' == 'netstandard' OR 
						   '%(Filename)' == 'WindowsBase' OR 
						   '%(Filename)' == 'PresentationCore' OR 
						   '%(Filename)' == 'PresentationFramework' OR 
						   $([System.String]::new('%(Filename)').StartsWith('PresentationFramework.')) OR 
						   '%(Filename)' == 'PresentationUI' OR 
						   '%(Filename)' == 'ReachFramework' OR 
						   '%(Filename)' == 'UIAutomationClient' OR 
						   '%(Filename)' == 'UIAutomationClientSideProviders' OR 
						   '%(Filename)' == 'UIAutomationProvider' OR 
						   '%(Filename)' == 'UIAutomationTypes' OR 
						   '%(Filename)' == 'Accessibility'" />
			
			<!-- Include only non-framework assemblies in the lib folder -->
			<_NonFrameworkAssemblies Include="@(_AllReferences)" Exclude="@(_FrameworkAssemblies);@(_NuGetReferences);@(_ProjectReferenceOutputs)" />
			<_AssemblyReferences Include="@(_NonFrameworkAssemblies)" Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.exe'" />
			<TfmSpecificPackageFile Include="@(_AssemblyReferences)" PackagePath="lib/$(TargetFramework)/" />
		</ItemGroup>
		
		<Message Text="Including in package: %(_NonFrameworkAssemblies.Identity)" Importance="low" />
	</Target>

	<!-- 
		Package metadata that applies to all projects.
		Individual projects can override these by setting them in their .csproj files.
	-->
	<PropertyGroup Condition="'$(GeneratePackageOnBuild)' == 'true'">
		<!-- Authors, Copyright, etc. can be set here if not already defined in individual projects -->
		<Authors Condition="'$(Authors)' == ''">Peter Wagner (A.K.A Wagnerp) and Simon Coghlan (A.K.A Smurf-IV), Phil Wright (A.K.A ComponentFactory), et al.</Authors>
		<Company Condition="'$(Company)' == ''">Krypton Suite</Company>
		<Copyright Condition="'$(Copyright)' == ''">Copyright Â© 2017 - $([System.DateTime]::Now.Year), Krypton Suite</Copyright>
		<PackageProjectUrl Condition="'$(PackageProjectUrl)' == ''">https://github.com/Krypton-Suite/Extended-Toolkit</PackageProjectUrl>
		<RepositoryUrl Condition="'$(RepositoryUrl)' == ''">https://github.com/Krypton-Suite/Extended-Toolkit.git</RepositoryUrl>
		<RepositoryType Condition="'$(RepositoryType)' == ''">git</RepositoryType>
		<PackageLicenseExpression Condition="'$(PackageLicenseExpression)' == '' and '$(PackageLicenseFile)' == ''">BSD-3-Clause</PackageLicenseExpression>
		<PackageRequireLicenseAcceptance Condition="'$(PackageRequireLicenseAcceptance)' == ''">true</PackageRequireLicenseAcceptance>
		<PackageTags Condition="'$(PackageTags)' == ''">Krypton ComponentFactory WinForms Themes Controls DataGrid Ribbon Workspace Tabs .Net Toolkit Core Extended</PackageTags>
		
		<!-- Prevent ProjectReferences from being converted to PackageReferences -->
		<!-- This ensures that Extended Toolkit projects don't create package dependencies on each other -->
		<!-- The assemblies are still included via the CopyProjectReferencesToPackage target -->
		<SuppressDependenciesWhenPacking>false</SuppressDependenciesWhenPacking>
	</PropertyGroup>
	
	<!-- 
		Remove Extended Toolkit ProjectReferences from package dependencies.
		This prevents Extended Toolkit projects from creating package dependencies on each other.
		The assemblies are still included in the package via the CopyProjectReferencesToPackage target.
	-->
	<Target Name="RemoveExtendedToolkitProjectReferencesFromPackageDependencies" BeforeTargets="GenerateNuspec" Condition="'$(GeneratePackageOnBuild)' == 'true'">
		<ItemGroup>
			<!-- Find all ProjectReferences to Extended Toolkit projects -->
			<_ExtendedToolkitProjectReferences Include="@(ProjectReference)" 
				Condition="$([System.String]::Copy('%(Identity)').Contains('Krypton.Toolkit.Suite.Extended'))" />
		</ItemGroup>
		
		<!-- Remove package dependencies that match Extended Toolkit project package IDs -->
		<ItemGroup>
			<_PackageDependenciesToRemove Include="@(_ExtendedToolkitProjectReferences->Metadata('PackageId'))" 
				Condition="'%(_ExtendedToolkitProjectReferences.PackageId)' != ''" />
			<!-- Also check by project name pattern -->
			<_PackageDependenciesToRemove Include="@(_PackageDependencies)" 
				Condition="$([System.String]::Copy('%(Identity)').StartsWith('Krypton.Toolkit.Suite.Extended'))" />
		</ItemGroup>
		
		<ItemGroup>
			<_PackageDependencies Remove="@(_PackageDependenciesToRemove)" />
		</ItemGroup>
	</Target>

	<!-- 
		Conditionally include README.md file in packages if it exists in the project directory.
		This prevents the "Readme missing" warning for projects that don't have README files.
	-->
	<Target Name="IncludeReadmeIfExists" BeforeTargets="GenerateNuspec" Condition="'$(GeneratePackageOnBuild)' == 'true'">
		<ItemGroup>
			<!-- Check if README.md exists in the project directory -->
			<_ReadmeFile Include="$(MSBuildProjectDirectory)\README.md" Condition="Exists('$(MSBuildProjectDirectory)\README.md')" />
			<_ReadmeFile Include="$(MSBuildProjectDirectory)\Readme.md" Condition="Exists('$(MSBuildProjectDirectory)\Readme.md')" />
		</ItemGroup>
		
		<!-- Include README.md in package if it exists -->
		<ItemGroup Condition="'@(_ReadmeFile)' != ''">
			<None Include="@(_ReadmeFile)" Pack="true" PackagePath="" />
		</ItemGroup>
		
		<!-- Set PackageReadmeFile property if README exists and not already set -->
		<PropertyGroup Condition="'@(_ReadmeFile)' != '' and '$(PackageReadmeFile)' == ''">
			<PackageReadmeFile>README.md</PackageReadmeFile>
		</PropertyGroup>
	</Target>

</Project>

